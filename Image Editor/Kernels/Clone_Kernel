__kernel void improve_clone(__global const int * dimensions, __global const int * scene, __global const int * clone, __global const float * mask, __global const float * merged_data, __global float * result){
int INTERIOR = 0;
int EXTERIOR = 1;
int BORDER = 2;

int group_id = get_group_id(0);
int group_size   = get_local_size(0);
int local_number = get_local_id(0);

int i = (group_id * group_size) + local_number;


int height = dimensions[0];
int width = dimensions[1];

int row = i / width;
int col = i % width;

int northAdjust = row - 1;
int southAdjust = row + 1;
int eastAdjust = col + 1;
int westAdjust = col - 1;


int northIndex = northAdjust * width + col;
int southIndex = southAdjust * width + col;
int eastIndex = row * width + eastAdjust;
int westIndex = row * width + westAdjust;

float A = 0;
float B = 0;
float C = 0; 
float D = 0;
int neighborCount = 0;

int currentClone = clone[i];


if(mask[i] == INTERIOR){
	if(northAdjust >= 0){
		float mergedNorth = merged_data[northIndex];
		float northMask = mask[northIndex]; 
		int sceneNorth = scene[northIndex];
		int cloneNorth = clone[northIndex];
		
		if(northMask == INTERIOR){
			A += mergedNorth;
		}
		else if(northMask == BORDER){
			B+= sceneNorth;
		}
		
		C += (currentClone - cloneNorth);
	
		neighborCount++;
	}
		
	if(southAdjust < height){
		float mergedSouth = merged_data[southIndex];
		float southMask = mask[southIndex];
		int sceneSouth = scene[southIndex];
		int cloneSouth = clone[southIndex];
		
		if(southMask == INTERIOR){
			A += mergedSouth;
		}
		else if(southMask == BORDER){
			B+= sceneSouth;
		}
		
		C += (currentClone - cloneSouth);
	
		neighborCount++;
	}
		
	if(eastAdjust < width){
		float mergedEast = merged_data[eastIndex];
		float eastMask = mask[eastIndex];
		int sceneEast = scene[eastIndex];
		int cloneEast = clone[eastIndex];
		
		if(eastMask == INTERIOR){
			A += mergedEast;
		}
		else if(eastMask == BORDER){
			B+= sceneEast;
		}
	
		C += (currentClone - cloneEast);
	
		neighborCount++;
	}
		
	if(westAdjust >= 0){
		float mergedWest = merged_data[westIndex];
		float westMask = mask[westIndex];
		int sceneWest = scene[westIndex];
		int cloneWest = clone[westIndex];
		
		if(westMask == INTERIOR){
			A += mergedWest;
		}
		else if(westMask == BORDER){
			B+= sceneWest;
		}
		
		C += (currentClone - cloneWest);
		
		neighborCount++;
	}
	
	result[i] = (A + B + C) / D;

}

}


__kernel void intial_guess(__global const int * scene, __global const int * clone, __global const float * mask, __global float * result){
int INTERIOR = 0;
int EXTERIOR = 1;
int BORDER = 2;

int group_id = get_group_id(0);
int group_size   = get_local_size(0);
int local_number = get_local_id(0);

int i = (group_id * group_size) + local_number;

int maskValue = mask[i];

if(maskValue != INTERIOR){
	result[i] = scene[i];
}
else{
	result[i] = clone[i];
}

}


__kernel void generate_mask(__global const int * dimensions, __global const float * alpha, __global float * mask){
int INTERIOR = 0;
int EXTERIOR = 1;
int BORDER = 2;

int group_id = get_group_id(0);
int group_size   = get_local_size(0);
int local_number = get_local_id(0);

int i = (group_id * group_size) + local_number;

int cloneHeight = dimensions[0];
int cloneWidth = dimensions[1];

int row = i / cloneWidth;
int col = i % cloneWidth;


int northAdjust = row - 1;
int southAdjust = row + 1;
int eastAdjust = col + 1;
int westAdjust = col - 1;


int northIndex = northAdjust * cloneWidth + col;
int southIndex = southAdjust * cloneWidth + col;
int eastIndex = row * cloneWidth + eastAdjust;
int westIndex = row * cloneWidth + westAdjust;

float currentAlpha = alpha[i];

if(currentAlpha == 0.0){
	mask[i] = EXTERIOR;
}
else{
	
	float north = -3.14;
	float south = -3.14;
	float east = -3.14;
	float west = -3.14;
	
	if(northAdjust >= 0){
		north = alpha[northIndex];
	}
	
	if(southAdjust < cloneHeight){
		south = alpha[southIndex];
	}
	
	if(eastAdjust < cloneWidth){
		east = alpha[eastIndex];
	}
	
	if(westAdjust >= 0){
		west = alpha[westIndex];
	}
	
	if(north != 0.0 && south != 0.0 && east != 0.0 && west != 0.0){
		mask[i] = INTERIOR;
	}
	else{
		mask[i] = BORDER;
	}
	
}

}




__kernel void int_cast(__global const float * data, __global int * result){
int group_id = get_group_id(0);
int group_size   = get_local_size(0);
int local_number = get_local_id(0);

int i = (group_id * group_size) + local_number;

result[i] = (int) data[i];
}



__kernel void seperate_channels(__global const int * data, __global float * redData, __global float * blueData, __global float * greenData, __global float * alphaData){
int ALPHA_MASK = 0xff000000;
int ALPHA_OFFSET = 24;
int RED_MASK = 0x00ff0000;
int RED_OFFSET = 16;
int GREEN_MASK = 0x0000ff00;
int GREEN_OFFSET = 8;
int BLUE_MASK = 0x000000ff;
int BLUE_OFFSET = 0;


int group_id = get_group_id(0);
int group_size   = get_local_size(0);
int local_number = get_local_id(0);

int i = (group_id * group_size) + local_number;


int pixel = data[i];

int red = (pixel & RED_MASK) >> RED_OFFSET;
int green = (pixel & GREEN_MASK) >> GREEN_OFFSET;
int blue = (pixel & BLUE_MASK) >> BLUE_OFFSET;
int alpha = (pixel & ALPHA_MASK) >> ALPHA_OFFSET;

redData[i] = (float) red;
blueData[i] = (float) blue;
greenData[i] = (float) green;
alphaData[i] = (float) alpha;



}